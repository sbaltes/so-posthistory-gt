Id;PostId;UserId;PostHistoryTypeId;RevisionGUID;CreationDate;Text;UserDisplayName;Comment
57612993;21662629;801189;2;78ee98d9-7c30-4f78-86dd-4e143a7c0a67;2014-02-09 17:48:04.0;"I have an outer array of N inner arrays of size M. I want to sort each inner array according to another array `K` exactly in the same way as a built-in `Array.Sort<TKey, TValue> Method (TKey[], TValue[], IComparer<TKey>)` [.NET method][1] [does][2].&#xD;&#xA;&#xD;&#xA;The method modifies the Key array after sorting, so I can use it to sort only single inner array. To sort many arrays, I copy the `Key` array to another `KeyBuffer` array for each inner array, reusing the KeyBuffer on each sorting step and avoiding allocation and GC. Is that the most efficient way if the typical N is 10K-100K and M < 1000? Given the low size of M the copying and sorting should be done in CPU cache, - which is the fastest that I can get?&#xD;&#xA;&#xD;&#xA;My concern is that by doing so, I am sorting the buffer and discarding the results (N-1) times, which is a kind of waste. Also I am doing actual sorting N times, but after the first sorting I already know a map of old indexes to new indexes and I could somehow reuse that mapping for other (N-1) steps.&#xD;&#xA;&#xD;&#xA;How would you avoid unnecessary sorting and apply known mapping from the first step to other steps?&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://msdn.microsoft.com/en-us/library/x8kwfbye%28v=vs.110%29.aspx&#xD;&#xA;  [2]: http://stackoverflow.com/questions/1964234/sorting-an-array-related-to-another-array";;
57614064;21662629;801189;5;97289128-7d13-4e2e-aaec-52d5e636e1b6;2014-02-09 18:12:26.0;"I have an outer array of N inner arrays of size M. I want to sort each inner array according to another array `K` exactly in the same way as a built-in `Array.Sort<TKey, TValue> Method (TKey[], TValue[], IComparer<TKey>)` [.NET method][1] [does][2].&#xD;&#xA;&#xD;&#xA;The method modifies the Key array after sorting, so I can use it to sort only single inner array. To sort many arrays, I copy the `Key` array to another `KeyBuffer` array for each inner array, reusing the KeyBuffer on each sorting step and avoiding allocation and GC. Is that the most efficient way if the typical N is 10K-100K and M < 1000? Given the low size of M the copying and sorting should be done in CPU cache, - which is the fastest that I can get?&#xD;&#xA;&#xD;&#xA;My concern is that by doing so, I am sorting the buffer and discarding the results (N-1) times, which is a kind of waste. Also I am doing actual sorting N times, but after the first sorting I already know a map of old indexes to new indexes and I could somehow reuse that mapping for other (N-1) steps.&#xD;&#xA;&#xD;&#xA;How would you avoid unnecessary sorting and apply known mapping from the first step to other steps?&#xD;&#xA;&#xD;&#xA;Here is the code how I do it now. The question is if it is possible to do it more efficiently.&#xD;&#xA;&#xD;&#xA;    using System;&#xD;&#xA;    using System.Collections.Generic;&#xD;&#xA;    &#xD;&#xA;    namespace MultiSorting {&#xD;&#xA;        class Program {&#xD;&#xA;            static void Main(string[] args) {&#xD;&#xA;    &#xD;&#xA;                var N = 10;&#xD;&#xA;                var M = 5;&#xD;&#xA;                var outer = new List<string[]>(N);&#xD;&#xA;    &#xD;&#xA;                for (var i = 0; i < N; i++) {&#xD;&#xA;                    string[] inner = { ""a"" + i, ""d"" + i, ""c"" + i, ""b"" + i, ""e"" + i };&#xD;&#xA;                    outer.Add(inner);&#xD;&#xA;                }&#xD;&#xA;    &#xD;&#xA;                int[] keys = { 1, 4, 3, 2, 5 };&#xD;&#xA;    &#xD;&#xA;                var keysBuffer = new int[M];&#xD;&#xA;                for (int i = 0; i < N; i++) {&#xD;&#xA;                    Array.Copy(keys, keysBuffer, M);&#xD;&#xA;                    // doing sort N times, but we know the map &#xD;&#xA;                    // old_index -> new_index from the first sorting&#xD;&#xA;                    // plus we sort keysBuffer N times but use the result only one time&#xD;&#xA;                    Array.Sort(keysBuffer, outer[i]); &#xD;&#xA;                }&#xD;&#xA;                keys = keysBuffer;&#xD;&#xA;    &#xD;&#xA;                foreach (var key in keys) {&#xD;&#xA;                    Console.Write(key + "" ""); // 1, 2, 3, 4, 5&#xD;&#xA;                }&#xD;&#xA;                Console.WriteLine("""");&#xD;&#xA;                for (var i = 0; i < N; i++) {&#xD;&#xA;                    foreach (var item in outer[i]) {&#xD;&#xA;                        Console.Write(item + "" ""); // a{i}, b{i}, c{i}, d{i}, e{i}&#xD;&#xA;                    }&#xD;&#xA;                    Console.WriteLine("""");&#xD;&#xA;                }&#xD;&#xA;                Console.ReadLine();&#xD;&#xA;            }&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;  [1]: http://msdn.microsoft.com/en-us/library/x8kwfbye%28v=vs.110%29.aspx&#xD;&#xA;  [2]: http://stackoverflow.com/questions/1964234/sorting-an-array-related-to-another-array";;Added code
146271141;21662629;-1;5;8bb276fe-c82f-48d9-892c-0f86cdbece96;2017-05-23 10:33:22.0;"I have an outer array of N inner arrays of size M. I want to sort each inner array according to another array `K` exactly in the same way as a built-in `Array.Sort<TKey, TValue> Method (TKey[], TValue[], IComparer<TKey>)` [.NET method][1] [does][2].&#xD;&#xA;&#xD;&#xA;The method modifies the Key array after sorting, so I can use it to sort only single inner array. To sort many arrays, I copy the `Key` array to another `KeyBuffer` array for each inner array, reusing the KeyBuffer on each sorting step and avoiding allocation and GC. Is that the most efficient way if the typical N is 10K-100K and M < 1000? Given the low size of M the copying and sorting should be done in CPU cache, - which is the fastest that I can get?&#xD;&#xA;&#xD;&#xA;My concern is that by doing so, I am sorting the buffer and discarding the results (N-1) times, which is a kind of waste. Also I am doing actual sorting N times, but after the first sorting I already know a map of old indexes to new indexes and I could somehow reuse that mapping for other (N-1) steps.&#xD;&#xA;&#xD;&#xA;How would you avoid unnecessary sorting and apply known mapping from the first step to other steps?&#xD;&#xA;&#xD;&#xA;Here is the code how I do it now. The question is if it is possible to do it more efficiently.&#xD;&#xA;&#xD;&#xA;    using System;&#xD;&#xA;    using System.Collections.Generic;&#xD;&#xA;    &#xD;&#xA;    namespace MultiSorting {&#xD;&#xA;        class Program {&#xD;&#xA;            static void Main(string[] args) {&#xD;&#xA;    &#xD;&#xA;                var N = 10;&#xD;&#xA;                var M = 5;&#xD;&#xA;                var outer = new List<string[]>(N);&#xD;&#xA;    &#xD;&#xA;                for (var i = 0; i < N; i++) {&#xD;&#xA;                    string[] inner = { ""a"" + i, ""d"" + i, ""c"" + i, ""b"" + i, ""e"" + i };&#xD;&#xA;                    outer.Add(inner);&#xD;&#xA;                }&#xD;&#xA;    &#xD;&#xA;                int[] keys = { 1, 4, 3, 2, 5 };&#xD;&#xA;    &#xD;&#xA;                var keysBuffer = new int[M];&#xD;&#xA;                for (int i = 0; i < N; i++) {&#xD;&#xA;                    Array.Copy(keys, keysBuffer, M);&#xD;&#xA;                    // doing sort N times, but we know the map &#xD;&#xA;                    // old_index -> new_index from the first sorting&#xD;&#xA;                    // plus we sort keysBuffer N times but use the result only one time&#xD;&#xA;                    Array.Sort(keysBuffer, outer[i]); &#xD;&#xA;                }&#xD;&#xA;                keys = keysBuffer;&#xD;&#xA;    &#xD;&#xA;                foreach (var key in keys) {&#xD;&#xA;                    Console.Write(key + "" ""); // 1, 2, 3, 4, 5&#xD;&#xA;                }&#xD;&#xA;                Console.WriteLine("""");&#xD;&#xA;                for (var i = 0; i < N; i++) {&#xD;&#xA;                    foreach (var item in outer[i]) {&#xD;&#xA;                        Console.Write(item + "" ""); // a{i}, b{i}, c{i}, d{i}, e{i}&#xD;&#xA;                    }&#xD;&#xA;                    Console.WriteLine("""");&#xD;&#xA;                }&#xD;&#xA;                Console.ReadLine();&#xD;&#xA;            }&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;  [1]: http://msdn.microsoft.com/en-us/library/x8kwfbye%28v=vs.110%29.aspx&#xD;&#xA;  [2]: https://stackoverflow.com/questions/1964234/sorting-an-array-related-to-another-array";;replaced http://stackoverflow.com/ with https://stackoverflow.com/

Id;PostId;UserId;PostHistoryTypeId;RevisionGUID;CreationDate;Text;UserDisplayName;Comment
114314795;36273118;4721831;2;8058910b-c25e-40e7-b85d-7258803adc90;2016-03-28 23:49:29.0;"To clarify your question and collocate the classes you are asking for, it  is essential to divide testing in two categories. JUnit tests as are widespread understood as a conceptual Java meaning and Instrumentation tests (that also are part of the JUnit test package but are more functional). In reality the situation is much more complex but here we simplify.&#xD;&#xA;&#xD;&#xA;Traditional JUnit tests  isolate a section of code and run a test. Instrumentation tests access instead more inclusively the android components. BUT ALSO THE INSTRUMENTATION TESTS DERIVE FROM THE JUNIT PACKAGE although they are instantiated in the system even before any application code is run and this explain why are slower. &#xD;&#xA;&#xD;&#xA;(Follow in Bold all the class you mention, others are with a normal character but not for this less important)&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;***A)***  Junit tests that extend TextCase (are usually faster than Instrumentation, and combine well with Mock framweworks)&#xD;&#xA;&#xD;&#xA;**AndroidTestCase**: It allows to have access to the Context of the Activity you are testing and their resources, it is a base class that extends more specialized subclasses, it is ideal to access databases, filesystem data. You can easily call getContext() and access the Resources without establishing a direct contact with the Activities as will be with Instrumentation tests.&#xD;&#xA;&#xD;&#xA;**ApplicationTestCase** that controls the environment where you text tha application, mainly the context and the life cycle. Other really useful extensions of AndroidTestCase allow you to control Loaders,Services,and Content Providers, but for some reason still not any Broadcast receiver that you can call it [indirectly][1] with  the method InstrumentationRegistry.getTargetContext() and then instantiating BroadCastReceiver. Also it is really common to use different Mock framework with Junit that is usually faster than InstrumentationTests&#xD;&#xA;&#xD;&#xA;-.-.-.-.-.-.-.-.--&#xD;&#xA;&#xD;&#xA;***B)*** Instrumentation tests, that extend TestCase&#xD;&#xA;Are considered functional tests, focused more to insure that they work well with the user side, the View part of MVC.They are usually slower than the other mentioned category&#xD;&#xA;&#xD;&#xA;**InstrumentationTestCase**  is a base class useful to send key events to UI to simulate QWERTY keyboard keys or DPAD buttons,also it launches the Activity that have to be tested, and even Intents&#xD;&#xA;&#xD;&#xA;**ActivityTestCase** Usually is not used alone,it just has common code for the subclasses, but in the case you are not satisfied by the 3 classes that inherit from this one(see below) like a new future component you can use it by the time will not exist a TestCase class dedicated. &#xD;&#xA;&#xD;&#xA;**ActivityInstrumentationTestCase2** is the most used Instrumentation class to write functional tests, from the constructor is invoked the instance of the Activity to test. Basically you call the activity with getActivity() and you can pratically run any method of that Activity.&#xD;&#xA;&#xD;&#xA;ActivityInstrumentationTestCase, is deprecated, and ActivityUnitTestCase that although is under the Instrumentation is more similar to an unit test&#xD;&#xA;&#xD;&#xA;";;
114781143;36273118;4721831;5;3d30b2f6-74de-4bea-ac13-fb4ba45304df;2016-04-03 18:52:55.0;"**INTRO**&#xD;&#xA;&#xD;&#xA;To clarify your question and collocate the classes you are asking for, it is essential BEFORE to divide testing in two categories. ***JUnit tests*** (in theory plain Java) and ***Instrumentation tests*** (that also are part of the JUnit test package but allow you to test more SDK Android related functionalities). &#xD;&#xA;&#xD;&#xA;Traditional JUnit tests isolate a section of code and run a test. Instrumentation tests access instead more inclusively the android components. BUT ALSO THE INSTRUMENTATION TESTS DERIVE FROM THE JUNIT PACKAGE although they are instantiated in the system even before any application code is run and this explain why are slower, furthermore they need an emulator or phone that run the app you are testing to be executed. &#xD;&#xA;&#xD;&#xA;(Follow in Bold all the class you mention, but there are others even more used that I will write without without the bold character).&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;****FIRST PART**(Junit tests)**&#xD;&#xA;&#xD;&#xA;***A)***  Junit tests that extend TextCase (are usually faster than Instrumentation, and combine well with Mock framweworks)&#xD;&#xA;&#xD;&#xA;**AndroidTestCase**: It allows to have access to the Context of the Activity you are testing and their resources, it is a base class that extends more specialized subclasses, it is ideal to access databases, filesystem data. You can easily call getContext() and access the Resources without establishing a direct contact with the Activities as will be with Instrumentation tests.&#xD;&#xA;&#xD;&#xA;**ApplicationTestCase** that controls the environment where you text tha application, mainly the context and the life cycle. Other really useful extensions of AndroidTestCase allow you to control Loaders,Services,and Content Providers, but for some reason still not any Broadcast receiver that you can call it [indirectly][1] with  the method InstrumentationRegistry.getTargetContext() and then instantiating BroadCastReceiver. Also it is really common to use different Mock framework with Junit that is usually faster than InstrumentationTests&#xD;&#xA;&#xD;&#xA;-.-.-.-.-.-.-.-.--&#xD;&#xA;&#xD;&#xA;****SECOND PART**(Instrumentation tests)**&#xD;&#xA;&#xD;&#xA;***B)*** **Instrumentation tests,** that extend TestCase&#xD;&#xA;Are considered functional tests, focused more to insure that they work well with the user side, the View part of MVC.They are usually slower than the other mentioned category&#xD;&#xA;&#xD;&#xA;**InstrumentationTestCase**  is a base class useful to send key events to UI to simulate QWERTY keyboard keys or DPAD buttons,also it launches the Activity that have to be tested, and even Intents&#xD;&#xA;&#xD;&#xA;**ActivityTestCase** Usually is not used alone,it just has common code for the subclasses, but in the case you are not satisfied by the 3 classes that inherit from this one(see below) like a new future component you can use it by the time will not exist a TestCase class dedicated. &#xD;&#xA;&#xD;&#xA;**ActivityInstrumentationTestCase2** is the most used Instrumentation class to write functional tests, from the constructor is invoked the instance of the Activity to test. Basically you call the activity with getActivity() and you can pratically run any method of that Activity.&#xD;&#xA;&#xD;&#xA;ActivityInstrumentationTestCase, is deprecated, and ActivityUnitTestCase that although is under the Instrumentation is more similar to an unit test&#xD;&#xA;&#xD;&#xA;";;added 167 characters in body
126280962;36273118;4721831;5;a208f71e-f271-4c50-b323-422c8fe60b30;2016-09-02 12:39:23.0;"**INTRO**&#xD;&#xA;&#xD;&#xA;To clarify your question and collocate the classes you are asking for, it is essential BEFORE to divide testing in two categories. ***JUnit tests*** (in theory plain Java) and ***Instrumentation tests*** (that also are part of the JUnit test package but allow you to test more SDK Android related functionalities). &#xD;&#xA;&#xD;&#xA;Traditional JUnit tests isolate a section of code and run a test. Instrumentation tests access instead more inclusively the android components. BUT ALSO THE INSTRUMENTATION TESTS DERIVE FROM THE JUNIT PACKAGE although they are instantiated in the system even before any application code is run and this explain why are slower, furthermore they need an emulator or phone that run the app you are testing to be executed. &#xD;&#xA;&#xD;&#xA;(Follow in Bold all the class you mention, but there are others even more used that I will write without without the bold character).&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;****FIRST PART**(Junit tests)**&#xD;&#xA;&#xD;&#xA;***A)***  Junit tests that extend TextCase (are usually faster than Instrumentation, and combine well with Mock framweworks)&#xD;&#xA;&#xD;&#xA;**AndroidTestCase**: It allows to have access to the Context of the Activity you are testing and their resources, it is a base class that extends more specialized subclasses, it is ideal to access databases, filesystem data. You can easily call getContext() and access the Resources without establishing a direct contact with the Activities as will be with Instrumentation tests.&#xD;&#xA;&#xD;&#xA;**ApplicationTestCase** that controls the environment where you text the application, mainly the context and the life cycle. Other really useful extensions of AndroidTestCase allow you to control Loaders,Services,and Content Providers, but for some reason still not any Broadcast receiver that you can call it [indirectly][1] with  the method InstrumentationRegistry.getTargetContext() and then instantiating BroadCastReceiver. Also it is really common to use different Mock framework with Junit that is usually faster than InstrumentationTests&#xD;&#xA;&#xD;&#xA;-.-.-.-.-.-.-.-.--&#xD;&#xA;&#xD;&#xA;****SECOND PART**(Instrumentation tests)**&#xD;&#xA;&#xD;&#xA;***B)*** **Instrumentation tests,** that extend TestCase&#xD;&#xA;Are considered functional tests, focused more to insure that they work well with the user side, the View part of MVC.They are usually slower than the other mentioned category&#xD;&#xA;&#xD;&#xA;**InstrumentationTestCase**  is a base class useful to send key events to UI to simulate QWERTY keyboard keys or DPAD buttons,also it launches the Activity that have to be tested, and even Intents&#xD;&#xA;&#xD;&#xA;**ActivityTestCase** Usually is not used alone,it just has common code for the subclasses, but in the case you are not satisfied by the 3 classes that inherit from this one(see below) like a new future component you can use it by the time will not exist a TestCase class dedicated. &#xD;&#xA;&#xD;&#xA;**ActivityInstrumentationTestCase2** is the most used Instrumentation class to write functional tests, from the constructor is invoked the instance of the Activity to test. Basically you call the activity with getActivity() and you can pratically run any method of that Activity.&#xD;&#xA;&#xD;&#xA;ActivityInstrumentationTestCase, is deprecated, and ActivityUnitTestCase that although is under the Instrumentation is more similar to an unit test&#xD;&#xA;&#xD;&#xA;";;edited body
126282216;36273118;4721831;5;7d581a10-dab3-4a46-b061-a7394f33b401;2016-09-02 12:57:01.0;"**INTRO**&#xD;&#xA;&#xD;&#xA;To clarify your question and collocate the classes you are asking for, it is essential BEFORE to divide testing in two categories. ***JUnit tests*** (in theory plain Java) and ***Instrumentation tests*** (that also are part of the JUnit test package but allow you to test more SDK Android related functionalities). &#xD;&#xA;&#xD;&#xA;Traditional JUnit tests isolate a section of code and run a test. Instrumentation tests access instead more inclusively the android components. BUT ALSO THE INSTRUMENTATION TESTS DERIVE FROM THE JUNIT PACKAGE although they are instantiated in the system even before any application code is run and this explain why are slower, furthermore they need an emulator or phone that run the app you are testing to be executed. &#xD;&#xA;&#xD;&#xA;(Follow in Bold all the class you mention, but there are others even more used that I will write without without the bold character).&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;****FIRST PART**(Junit tests)**&#xD;&#xA;&#xD;&#xA;***A)***  Junit tests that extend TextCase (are usually faster than Instrumentation, and combine well with Mock framweworks)&#xD;&#xA;&#xD;&#xA;**AndroidTestCase**: It allows to have access to the Context of the Activity you are testing and their resources, it is a base class that extends more specialized subclasses, it is ideal to access databases, filesystem data. You can easily call getContext() and access the Resources without establishing a direct contact with the Activities as will be with Instrumentation tests.&#xD;&#xA;&#xD;&#xA;**ApplicationTestCase** that controls the environment where you text the application, mainly the context and the life cycle. Other really useful extensions of AndroidTestCase allow you to control Loaders,Services,and Content Providers, but for some reason still not any Broadcast receiver that you can call it [indirectly][1] with  the method InstrumentationRegistry.getTargetContext() and then instantiating BroadCastReceiver. Also it is really common to use different Mock framework with Junit that is usually faster than InstrumentationTests&#xD;&#xA;&#xD;&#xA;-.-.-.-.-.-.-.-.--&#xD;&#xA;&#xD;&#xA;****SECOND PART**(Instrumentation tests)**&#xD;&#xA;&#xD;&#xA;***B)*** **Instrumentation tests,** that extend TestCase&#xD;&#xA;Are considered functional tests, focused more to insure that they work well with the user side, the View part of MVC.They are usually slower than the other mentioned category&#xD;&#xA;&#xD;&#xA;**InstrumentationTestCase**  is a base class useful to send key events to UI to simulate QWERTY keyboard keys or DPAD buttons,also it launches the Activity that have to be tested, and even Intents&#xD;&#xA;&#xD;&#xA;**ActivityTestCase** Usually is not used alone,it just has common code for the subclasses, but in the case you are not satisfied by the 3 classes that inherit from this one(see below) like a new future component you can use it by the time will not exist a TestCase class dedicated. &#xD;&#xA;&#xD;&#xA;**ActivityInstrumentationTestCase2** is the most used Instrumentation class to write functional tests, from the constructor is invoked the instance of the Activity to test. Basically you call the activity with getActivity() and you can pratically run any method of that Activity.&#xD;&#xA;&#xD;&#xA;ActivityInstrumentationTestCase, is deprecated, and ActivityUnitTestCase that although is under the Instrumentation is more similar to an unit test&#xD;&#xA;&#xD;&#xA;";;edited body
